# Think in Java——1 对象入门

[toc]

TIJ阅读笔记

### 封装：实现方案的隐藏

> Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，
> protected 以及暗示性的friendly。
>
> 若未明确指定其他关键字，则默认为后者（friendly）。这些关键字的使用和含义都是相当直观的，它们决定了谁能使用后续的定义内容。
>
> “public”（公共）意味着后续的定义任何人均可使用。
>
> “private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private 在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。
>
> “friendly ”（友好的）涉及“包装”或“封装”（Package）的概念——即Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。
>
> “protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员

### 重用：方案的重复使用

> 为代码或设计方案的重复使用是面向对象的程序设计提供的最伟大的一种杠杆。

+ 创建对象

>  为重复使用一个类，最简单的办法是仅直接使用那个类的对象。

+ 组织 (成员对象)

> 但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。无论如何，只要新类达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。

+ 继承

### 继承：重新使用接口

+ 子类与父类的等价性——相同的成员与接口、**可以视作相同的类型**

> 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。根据可以发送的消息，我们能知道类的类型。这意味着衍生类具有与基础类相同的类型！

+ 子类与父类的差异性

  + 扩展

  > 第一种做法十分简单：为衍生类添加新函数（功能）。这些新函数并非基础类接口的一部分。
  + 重写

  > 第二个办法是改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。为改善一个函数，只需为衍生类的函数建立一个新定义即可。我们的目标是：“尽管使用的函数接口未变，但它的新版本具有不同的表现”。
  
  + 等价与类似关系

### 多行对象的互换使用

> 种把衍生类型当作它的基本类型处理的过程叫作“Upcasting”（上溯造型）。

例如: 将String实例作为Object对象使用。

动态绑定：

> 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）。
>
> 实现多形性的方式叫做动态绑定

抽象的基础类和接口

abstract class\interface

### 对象的创建和存在时间

程序控制内存的分配与释放——C++

> C++认为程序的执行效率是最重要的一个问题，所以它允许程序员作出选择。为获得最快的运行速度，存储以及存在时间可在编写程序时决定，只需将对象放置在堆栈（有时也叫作自动或定域变量）或者静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。

托管、垃圾收集器——java ——额外的开销

> 在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可。由于存储空间的管理是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。

集合与继承器（迭代器 Iterator）

单根结构 所有类继承Object：对象具有共同的属性，为支持共有的操作提供便利，比如垃圾回收。

下溯造型：与上溯造型相对，把被处理成父类的对象复原为子类对象的过程。复原过程中存在出现异常的可能。

### 违例控制：解决错误。

异常抛出与异常处理

try-catch与throw

### 多线程

Thread资源共享与访问控制。

> 必须注意一个问题：共享资源！如果有多个线程同时运行，而且它们试图访问相同的资源，就会遇到一个问题。

> Java 也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized 关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。

### 永久性

> 假如在程序停止运行以后，对象也能继续存在，并能保留它的全部信息，那么在某些情况下将是一件非常有价值的事情。下次启动程序时，对象仍然在那里，里面保留的信息仍然是程序上一次运行时的那些信息。当然，可以将信息写入一个文件或者数据库，从而达到相同的效果。但尽管可将所有东西都看作一个对象，如果能将对象声明成“永久性”，并令其为我们照看其他所有细节，无疑也是一件相当方便的事情。 

### web

客户端与服务端编程（略过）

### 分析与设计

> 在整个开发过程中，最重要的事情就是：不要将自己迷失！但事实上这种事情很容易发生。大多数方法都设计用来解决最大范围内的问题。当然，也存在一些特别困难的项目，需要作者付出更为艰辛的努力，或者付出更大的代价。但是，大多数项目都是比较“常规”的，所以一般都能作出成功的分析与设计，而且只需用到推荐的一小部分方法。但无论多么有限，某些形式的处理总是有益的，这可使整个项目的开发更加容易，总比直接了当开始编码好！ 

#### **不要迷失**

> 时刻提醒自己注意以下几个问题： 
>
> (1) 对象是什么？（怎样将自己的项目分割成一系列单独的组件？）
> (2) 它们的接口是什么？（需要将什么消息发给每一个对象？）
>
> 在确定了对象和它们的接口后，便可着手编写一个程序。

##### 0 拟出一个计划

预定里程碑与大致的计划

> 但我觉得假如能在整个过程中设置几个标志，或者“路标”，将更有益于你集中注意力。这恐怕比单纯地为了“完成工作”而工作好得多。至少，在达到了一个又一个的目标，经过了一个接一个的路标以后，可对自己的进度有清晰的把握，干劲也会相应地提高，不会产生“路遥漫漫无期”的感觉。 

##### 1 要制作什么

需求分析

> 需求分析的意思是“建立一系列规则，根据它判断任务什么时候完成，以及客户怎样才能满意”。系统规格则表示“这里是一些具体的说明，让你知道程序需要做什么（而不是怎样做）才能满足要求”。

> 我们特别要注意将重点放在这一阶段的核心问题上，不要纠缠于细枝末节。这个核心问题就是：决定采用什么系统。对这个问题，最有价值的工具就是一个名为“使用条件”的集合。对那些采用“假如……，系统该怎样做？”形式的问题，这便是最有说服力的回答。
>
> 应尽可能总结出自己系统的一套完整的“使用条件”或者“应用场合”。

##### 2 如何构建

OOD

对对象和接口的说明

##### 3 开始构建

programming！！！

> 编程更象一门艺术，不能只是作为技术活来看待。所有付出最终都会得到回报。作为真正的程序员，这并非可有可无的一种素质。全面的思考、周密的准备、良好的构造不仅使程序更易构建与调试，也使其更易理解和维护，而那正是一套软件赢利的必要条件。 

##### 4 校订

测试-》递增-》测试-》 ...... -》维护